{% extends 'base.html' %}
{% load static %}

{% block title %}Driver Dashboard - Smart Transport{% endblock %}

{% block extra_head %}
<style>
    /* Driver Dashboard Styles */
    .dashboard-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }

    .dashboard-header {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        margin-bottom: 30px;
    }

    .welcome-section {
        margin-bottom: 20px;
    }

    .welcome-title {
        font-size: 2rem;
        font-weight: 700;
        color: var(--secondary);
        margin-bottom: 10px;
    }

    .driver-info {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
    }

    .info-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .info-label {
        font-weight: 600;
        color: #6b7280;
    }

    .info-value {
        color: var(--dark);
        font-weight: 600;
    }

    .dashboard-section {
        background: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        margin-bottom: 25px;
    }

    .section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--secondary);
        margin-bottom: 20px;
        border-bottom: 2px solid #e5e7eb;
        padding-bottom: 10px;
    }

    .tracking-controls {
        display: flex;
        gap: 15px;
        align-items: center;
        margin-bottom: 20px;
    }

    .tracking-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .start-tracking {
        background-color: #10b981;
        color: white;
    }

    .start-tracking:hover:not(:disabled) {
        background-color: #059669;
        transform: translateY(-2px);
    }

    .stop-tracking {
        background-color: #ef4444;
        color: white;
    }

    .stop-tracking:hover:not(:disabled) {
        background-color: #dc2626;
        transform: translateY(-2px);
    }

    .tracking-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
    }

    .tracking-status {
        padding: 15px;
        background-color: #f8fafc;
        border-radius: 8px;
        border-left: 4px solid var(--primary);
        margin: 15px 0;
        font-weight: 600;
    }

    /* Seat Grid Styles */
    .seat-grid {
        display: grid;
        gap: 10px;
        grid-template-columns: 80px 40px 40px 40px 40px 40px;
        grid-auto-rows: 48px;
        max-width: 400px;
        margin: 20px 0;
        padding: 20px;
        background: #f8fafc;
        border-radius: 12px;
    }

    .seat-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 6px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .seat-available {
        background-color: #10b981;
    }

    .seat-occupied {
        background-color: #ef4444;
    }

    .seat-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .seat-info {
        color: #6b7280;
        font-size: 0.9rem;
        margin-top: 10px;
    }

    /* Notifications Styles */
    .notifications-container {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        overflow: hidden;
    }

    .notifications-header {
        background: var(--secondary);
        color: white;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .notifications-badge {
        background: #ef4444;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        margin-left: 10px;
    }

    .clear-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: background 0.3s;
    }

    .clear-btn:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .notifications-list {
        height: 150px;
        overflow-y: auto;
        padding: 15px;
        background: #fafafa;
    }

    .notification-item {
        padding: 10px;
        margin-bottom: 8px;
        background: white;
        border-radius: 6px;
        border-left: 4px solid var(--accent);
        cursor: pointer;
        transition: background 0.3s;
    }

    .notification-item:hover {
        background: #f3f4f6;
    }

    .notification-item.selected {
        background: #e0f2fe;
        border-left-color: var(--primary);
    }

    /* Chat Styles */
    .chat-container {
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        overflow: hidden;
    }

    .chat-header {
        background: var(--secondary);
        color: white;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .chat-log {
        height: 200px;
        overflow-y: auto;
        padding: 15px;
        background: #fafafa;
        border-bottom: 1px solid #e5e7eb;
    }

    .chat-message {
        margin-bottom: 10px;
        padding: 8px 12px;
        border-radius: 8px;
        max-width: 80%;
    }

    .message-driver {
        background: var(--primary);
        color: white;
        margin-left: auto;
    }

    .message-user {
        background: white;
        border: 1px solid #e5e7eb;
        margin-right: auto;
    }

    .chat-input-container {
        display: flex;
        padding: 15px;
        gap: 10px;
        background: white;
    }

    .chat-input {
        flex: 1;
        padding: 12px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        font-size: 1rem;
    }

    .send-btn {
        background: var(--primary);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.3s;
    }

    .send-btn:hover {
        background: var(--secondary);
    }

    /* Bus Creation Form */
    .bus-creation-form {
        background: #f8fafc;
        padding: 25px;
        border-radius: 12px;
        border: 2px dashed #cbd5e1;
    }

    .form-group {
        margin-bottom: 20px;
    }

    .form-label {
        display: block;
        font-weight: 600;
        color: var(--dark);
        margin-bottom: 8px;
    }

    .form-input {
        width: 100%;
        max-width: 300px;
        padding: 12px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        font-size: 1rem;
    }

    .form-input:focus {
        border-color: var(--primary);
        outline: none;
        box-shadow: 0 0 0 3px rgba(26, 86, 219, 0.1);
    }

    .create-bus-btn {
        background: var(--primary);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .create-bus-btn:hover {
        background: var(--secondary);
        transform: translateY(-2px);
    }

    .pending-verification {
        background: #fef3c7;
        border: 2px solid #f59e0b;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
    }

    .pending-verification h3 {
        font-size: 1.5rem;
        color: #92400e;
        margin-bottom: 10px;
    }

    .no-route-assigned {
        background: #fee2e2;
        border: 2px solid #ef4444;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
    }

    .no-route-assigned h3 {
        font-size: 1.5rem;
        color: #991b1b;
        margin-bottom: 10px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .dashboard-container {
            padding: 10px;
        }

        .dashboard-header {
            padding: 20px;
        }

        .welcome-title {
            font-size: 1.5rem;
        }

        .driver-info {
            flex-direction: column;
            gap: 15px;
        }

        .tracking-controls {
            flex-direction: column;
        }

        .tracking-btn {
            width: 100%;
            justify-content: center;
        }

        .seat-grid {
            max-width: 100%;
        }

        .chat-input-container {
            flex-direction: column;
        }

        .send-btn {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-container">
    <!-- Dashboard Header -->
    <div class="dashboard-header">
        <div class="welcome-section">
            <h1 class="welcome-title">üöó Driver Dashboard</h1>
            <p style="color: #6b7280;">Welcome back, <strong>{{ request.user.username }}</strong>!</p>
        </div>
        <div class="driver-info">
            <div class="info-item">
                <span class="info-label">Vehicle Number:</span>
                <span class="info-value">{{ driver.vehicle_number }}</span>
            </div>
            {% if bus %}
                <div class="info-item">
                    <span class="info-label">Bus ID:</span>
                    <span class="info-value" id="busIdDisplay">{{ bus.id }}</span>
                </div>
            {% endif %}
        </div>
    </div>

    {% if driver.verified %}
        {% if route and bus %}
        <div class="dashboard-section" style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #3b82f6;">
            <h2 class="section-title" style="border: none; padding-bottom: 0; margin-bottom: 15px;">
                üîÑ Route Management
            </h2>
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 20px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 250px;">
                    <div style="font-size: 1.3rem; font-weight: 700; color: var(--secondary); margin-bottom: 8px;">
                        üìç Current Route: {{ route.name }}
                    </div>
                    <div style="font-size: 0.95rem; color: #6b7280; margin-bottom: 4px;">
                        üöè {{ route.get_stops_list|length }} stops
                    </div>
                    {% if route.reverse_route %}
                        <div style="font-size: 0.9rem; color: #3b82f6; font-weight: 600;">
                            ‚ÜîÔ∏è Reverse available: {{ route.reverse_route.name }}
                        </div>
                    {% endif %}
                </div>
                <div>
                    {% if route.reverse_route %}
                        <button id="switchRouteBtn" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; font-size: 1rem; cursor: pointer; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);">
                            üîÑ Switch to {{ route.reverse_route.name }}
                        </button>
                    {% else %}
                        <button style="background: #9ca3af; color: white; border: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; font-size: 1rem; cursor: not-allowed;" disabled>
                            üö´ No Reverse Route
                        </button>
                    {% endif %}
                </div>
            </div>
            
            {% if route.reverse_route %}
                <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #10b981;">
                    <p style="margin: 0; color: #059669; font-size: 0.9rem;">
                        <strong>üí° Pro Tip:</strong> After completing your route to the destination, 
                        click "Switch Route" to start the return journey.
                    </p>
                </div>
            {% endif %}
        </div>
            <!-- Tracking Section -->
            <div class="dashboard-section">
                <h2 class="section-title">üìç Live Location Tracking</h2>
                <div class="tracking-controls">
                    <button id="startTracking" class="tracking-btn start-tracking">
                        ‚ñ∂Ô∏è Start Tracking
                    </button>
                    <button id="stopTracking" class="tracking-btn stop-tracking" disabled>
                        ‚èπÔ∏è Stop Tracking
                    </button>
                </div>
                <div id="trackingStatus" class="tracking-status" style="display: none;"></div>
            </div>

            <!-- Seat Management Section -->
            <div class="dashboard-section">
                <h2 class="section-title">üí∫ Seat Arrangement ({{ bus.total_seats }} seats)</h2>
                <div class="seat-grid">
                    {% for seat, row, col in seat_grid_columns %}
                        <button class="seat-btn {% if seat.is_available %}seat-available{% else %}seat-occupied{% endif %}" 
                            data-seat-id="{{ seat.id }}" 
                            style="grid-column: {{ col }}; grid-row: {{ row }};">
                            {{ seat.seat_number }}
                        </button>
                    {% endfor %}
                </div>
                <div class="seat-info">
                    üü¢ Click a seat to toggle availability | Green = Available | Red = Occupied
                </div>
            </div>

<!-- Notifications Section -->
<div class="dashboard-section">
    <h2 class="section-title">üîî Pickup Notifications</h2>
    <div class="notifications-container">
        <div class="notifications-header">
            <div>
                <strong>Notifications</strong>
                <span id="notifBadge" class="notifications-badge" style="display: none;">0</span>
            </div>
            <button id="clearAllNotifs" class="clear-btn">Clear All</button>
        </div>
        <div id="driverNotifications" class="notifications-list">
            <div style="text-align: center; color: #9ca3af; padding: 20px;">
                No notifications yet
            </div>
        </div>
    </div>
</div>
<!-- ‚≠ê UPDATED: Notification styles (add to existing <style> section) -->
<style>
/* Notification group styles */
.notification-group {
    margin-bottom: 16px;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    overflow: hidden;
}

.notification-group-header {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 700;
}

.notification-rank {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    font-size: 0.9rem;
    margin-right: 8px;
}

.passenger-count-badge {
    background: rgba(255, 255, 255, 0.3);
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 0.85rem;
}

.notification-group-passengers {
    background: white;
}

.passenger-item {
    padding: 12px 16px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.2s;
}

.passenger-item:last-child {
    border-bottom: none;
}

.passenger-item:hover {
    background: #f3f4f6;
}

.passenger-item.unseen {
    background: #fef3c7;
}

.passenger-info {
    flex: 1;
}

.passenger-name {
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 4px;
}

.passenger-message {
    font-size: 0.85rem;
    color: #6b7280;
    margin-top: 4px;
}

.passenger-time {
    font-size: 0.75rem;
    color: #9ca3af;
    margin-top: 4px;
}

.clear-passenger-btn {
    background: #ef4444;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 0.8rem;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.clear-passenger-btn:hover {
    background: #dc2626;
    transform: translateY(-1px);
}
</style>

            <!-- Chat Section -->
            <div class="dashboard-section">
                <h2 class="section-title">üí¨ Chat with Passengers</h2>
                <div class="chat-container">
                    <div class="chat-header">
                        <strong>Conversation</strong>
                        <button id="clearDriverChat" class="clear-btn">Clear Chat</button>
                    </div>
                    <div id="driverChatLog" class="chat-log">
                        <div style="text-align: center; color: #9ca3af; padding: 20px;">
                            Select a notification to start chatting
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <input id="driverChatInput" class="chat-input" placeholder="Type your message..." />
                        <button id="driverSendChat" class="send-btn">Send</button>
                    </div>
                </div>
            </div>

        {% elif route and not bus %}
            <!-- Bus Creation Form -->
            <div class="dashboard-section">
                <h2 class="section-title">üöå Create Your Bus</h2>
                <div class="bus-creation-form">
                    <p style="margin-bottom: 20px; color: #6b7280;">
                        You need to create a bus to start operating. Please fill in the details below:
                    </p>
                    <form method="post">
                        {% csrf_token %}
                        <div class="form-group">
                            <label class="form-label">Total Seats *</label>
                            <input type="number" name="total_seats" min="10" max="60" value="25" 
                                   class="form-input" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Bus Number Plate *</label>
                            <input type="text" name="number_plate" class="form-input" 
                                   placeholder="e.g., BA 1 PA 8271" required>
                        </div>
                        <button type="submit" class="create-bus-btn">
                            ‚úì Create Bus
                        </button>
                    </form>
                </div>
            </div>
        {% else %}
            <!-- No Route Assigned -->
            <div class="no-route-assigned">
                <h3>‚ö†Ô∏è No Route Assigned</h3>
                <p>Please contact the administrator to assign a route to your account.</p>
            </div>
        {% endif %}
    {% else %}
        <!-- Pending Verification -->
        <div class="pending-verification">
            <h3>‚è≥ Verification Pending</h3>
            <p>Your driver account is pending admin verification. You will be notified once approved.</p>
        </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_scripts %}
<script>


{% if route and bus %}
// ==================== LOCATION TRACKING SYSTEM ====================
let socket;
let geoWatchId = null;
let lastSentLocation = null;
const busId = "{{ bus.id }}";
const startBtn = document.getElementById('startTracking');
const stopBtn = document.getElementById('stopTracking');
const status = document.getElementById('trackingStatus');

// Minimum distance (meters) before sending update
const MIN_DISTANCE_CHANGE = 10;

// Calculate distance between two coordinates
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth radius in meters
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Start tracking button
startBtn.addEventListener('click', function() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        console.log('WebSocket already open');
        return;
    }
    
    if (!navigator.geolocation) {
        status.style.display = 'block';
        status.className = 'tracking-status';
        status.style.backgroundColor = '#fee2e2';
        status.style.color = '#991b1b';
        status.innerHTML = '‚ùå Geolocation not supported by your browser.';
        return;
    }
    
    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + 
                  window.location.host + '/ws/location/' + busId + '/';
    
    console.log('Connecting to WebSocket:', wsUrl);
    socket = new WebSocket(wsUrl);
    
    socket.onopen = function() {
        console.log('‚úÖ WebSocket connected');
        status.style.display = 'block';
        status.innerHTML = '‚úÖ Tracking started successfully!';
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        lastSentLocation = null;
        
        const geoOptions = {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 0
        };
        
        console.log('Starting geolocation watch...');
        
        geoWatchId = navigator.geolocation.watchPosition(
            function(position) {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;
                
                console.log('üìç Location:', {
                    lat: lat.toFixed(6),
                    lng: lng.toFixed(6),
                    accuracy: accuracy.toFixed(0) + 'm'
                });
                
                // Check if location changed significantly
                let shouldSend = true;
                if (lastSentLocation) {
                    const distance = calculateDistance(
                        lastSentLocation.lat, lastSentLocation.lng,
                        lat, lng
                    );
                    
                    if (distance < MIN_DISTANCE_CHANGE) {
                        shouldSend = false;
                        console.log(`‚è≠Ô∏è Skipping (moved only ${distance.toFixed(1)}m)`);
                    }
                }
                
                if (shouldSend && socket.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'location',
                        lat: lat,
                        lng: lng
                    };
                    
                    socket.send(JSON.stringify(data));
                    lastSentLocation = { lat: lat, lng: lng };
                    console.log('üì§ Location sent to server');
                }
            }, 
            function(error) {
                console.error('‚ùå Geolocation error:', error);
                status.style.backgroundColor = '#fee2e2';
                status.style.color = '#991b1b';
                
                let errorMsg = '‚ùå GPS Error: ';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMsg += 'Permission denied. Please enable location access.';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMsg += 'Location unavailable. Check GPS is enabled.';
                        break;
                    case error.TIMEOUT:
                        errorMsg += 'Request timeout. Retrying...';
                        break;
                    default:
                        errorMsg += error.message;
                }
                status.innerHTML = errorMsg;
            }, 
            geoOptions
        );
        
        console.log('‚úÖ Geolocation watch started');
    };
    
// ‚≠ê IMPROVED: Smart GPS filtering - smooth when stationary, raw when moving
let gpsUpdateInterval = null;
let lastKnownPosition = null;
let recentPositions = []; // Track recent positions for movement detection
const POSITION_BUFFER_SIZE = 3;
let isDriverMoving = false;
let gpsReadingsCount = 0; // ‚≠ê ADD THIS
let gpsStabilized = false; // ‚≠ê ADD THIS
let firstGoodReading = false;

// ‚≠ê Detect if driver is actually moving
function detectMovement(lat, lng) {
    recentPositions.push({ lat, lng, timestamp: Date.now() });
    
    // Keep only last 3 positions
    if (recentPositions.length > POSITION_BUFFER_SIZE) {
        recentPositions.shift();
    }
    
    // Need at least 2 positions to detect movement
    if (recentPositions.length < 2) {
        return false;
    }
    
    // Check if driver moved significantly in last 2 readings
    const last = recentPositions[recentPositions.length - 1];
    const previous = recentPositions[recentPositions.length - 2];
    
    const distance = calculateDistance(
        previous.lat, previous.lng,
        last.lat, last.lng
    );
    
    // Driver is moving if traveled >5m between readings
    return distance > 20;
}

// ‚≠ê Simple noise filter - only removes small jitter
function filterJitter(lat, lng) {
    if (recentPositions.length === 0) {
        return { lat, lng };
    }
    
    const last = recentPositions[recentPositions.length - 1];
    const distance = calculateDistance(last.lat, last.lng, lat, lng);

    // If movement < 15m, assume it's GPS noise and keep previous position
    if (distance < 15) {
        return { lat: last.lat, lng: last.lng };
    }
    
    // Otherwise use the new position (driver is actually moving)
    return { lat, lng };
}

socket.onopen = function() {
    console.log('‚úÖ WebSocket connected');
    status.style.display = 'block';
    status.innerHTML = '‚úÖ Tracking started successfully!';
    startBtn.disabled = true;
    stopBtn.disabled = false;
    
    lastSentLocation = null;
    recentPositions = []; // ‚≠ê Reset
    isDriverMoving = false;
        gpsReadingsCount = 0; // ‚≠ê RESET
    gpsStabilized = false; // ‚≠ê RESET
    
    const geoOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
    };
    
    console.log('Starting geolocation watch...');
    
 geoWatchId = navigator.geolocation.watchPosition(
    function(position) {
        const rawLat = position.coords.latitude;
        const rawLng = position.coords.longitude;
        const accuracy = position.coords.accuracy;
        
        // ‚≠ê SMART WARMUP: Accept if accuracy is good, regardless of reading count
        if (!gpsStabilized) {
            if (accuracy <= 30) {
                // GPS accuracy is good enough - start immediately!
                gpsStabilized = true;
                firstGoodReading = true;
                status.innerHTML = '‚úÖ GPS locked! Tracking active.';
                console.log(`‚úÖ GPS stabilized immediately (accuracy: ${accuracy.toFixed(0)}m)`);
            } else {
                // Still waiting for good accuracy
                console.log(`üîÑ GPS warming up... (accuracy: ${accuracy.toFixed(0)}m, need <30m)`);
                status.innerHTML = `üîÑ GPS warming up... (accuracy: ${accuracy.toFixed(0)}m)`;
                return; // ‚≠ê Skip this reading
            }
        }
        
        // ‚≠ê After stabilization, still ignore readings with accuracy >50m
        if (accuracy > 50) {
            console.log(`‚ö†Ô∏è Ignoring low-accuracy GPS: ${accuracy.toFixed(0)}m`);
            return;
        }

        // ‚≠ê NEW: Completely reject terrible accuracy
if (accuracy > 100) {
    console.log(`‚ùå GPS accuracy too poor: ${accuracy.toFixed(0)}m - skipping completely`);
    return;
}
            
            // ‚≠ê Detect if driver is moving
            const moving = detectMovement(rawLat, rawLng);
            
            let lat, lng;
            
            if (moving) {
                // ‚≠ê Driver is MOVING - use RAW GPS (no smoothing)
                lat = rawLat;
                lng = rawLng;
                isDriverMoving = true;
                console.log(`üöó MOVING: Using raw GPS (${lat.toFixed(6)}, ${lng.toFixed(6)})`);
            } else {
                // ‚≠ê Driver is STATIONARY - filter small jitter
                const filtered = filterJitter(rawLat, rawLng);
                lat = filtered.lat;
                lng = filtered.lng;
                isDriverMoving = false;
                console.log(`üõë STATIONARY: Using filtered GPS (raw was ${rawLat.toFixed(6)}, ${rawLng.toFixed(6)})`);
            }
            
            // Update last known position
            lastKnownPosition = { lat, lng, accuracy, moving };
            
            console.log('üìç GPS:', {
                raw: `${rawLat.toFixed(6)}, ${rawLng.toFixed(6)}`,
                used: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                accuracy: accuracy.toFixed(0) + 'm',
                moving: moving ? 'YES' : 'NO'
            });
        },
        function(error) {
            console.error('‚ùå Geolocation error:', error);
            status.style.backgroundColor = '#fee2e2';
            status.style.color = '#991b1b';
            
            let errorMsg = '‚ùå GPS Error: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMsg += 'Permission denied. Please enable location access.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMsg += 'Location unavailable. Check GPS is enabled.';
                    break;
                case error.TIMEOUT:
                    errorMsg += 'Request timeout. Retrying...';
                    break;
                default:
                    errorMsg += error.message;
            }
            status.innerHTML = errorMsg;
        },
        geoOptions
    );
    
    // ‚≠ê ADAPTIVE SENDING: Fast when moving, slow when stationary
    gpsUpdateInterval = setInterval(() => {
          // ‚≠ê Don't send until GPS is stabilized
        if (!gpsStabilized) {
            return;
        }
        if (lastKnownPosition && socket.readyState === WebSocket.OPEN) {
            const { lat, lng, moving } = lastKnownPosition;
            
            // Determine if we should send this update
            let shouldSend = true;
            
            if (lastSentLocation) {
                const distance = calculateDistance(
                    lastSentLocation.lat, lastSentLocation.lng,
                    lat, lng
                );
                
                const timeSinceLastSend = (Date.now() - (lastSentLocation.timestamp || 0)) / 1000;
                
                if (moving) {
                    // ‚≠ê MOVING: Send if moved >8m OR every 3 seconds
                    if (distance < 8 && timeSinceLastSend < 3) {
                        shouldSend = false;
                    }
                } else {
                    // ‚≠ê STATIONARY: Send only if moved >10m OR every 10 seconds
                    if (distance < 10 && timeSinceLastSend < 10) {
                        shouldSend = false;
                    }
                }
            }
            
            if (shouldSend) {
                const data = {
                    type: 'location',
                    lat: lat,
                    lng: lng
                };
                
                socket.send(JSON.stringify(data));
                lastSentLocation = { lat, lng, timestamp: Date.now() };
                
                if (moving) {
                    console.log('üì§ Sent (MOVING)');
                } else {
                    console.log('üì§ Sent (STATIONARY)');
                }
            }
        }
    }, 2000); // Check every 2 seconds
    
    console.log('‚úÖ GPS: Smart tracking enabled (raw when moving, filtered when stationary)');
};
    
    socket.onerror = function(error) {
        console.error('‚ùå WebSocket error:', error);
        status.style.backgroundColor = '#fee2e2';
        status.style.color = '#991b1b';
        status.innerHTML = '‚ùå Connection error. Check your internet.';
    };
    
    socket.onclose = function(event) {
        console.log('‚ö†Ô∏è WebSocket closed');
        status.style.backgroundColor = '#fef3c7';
        status.style.color = '#92400e';
        status.innerHTML = '‚ö†Ô∏è Connection closed.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
        
        if (geoWatchId !== null) {
            navigator.geolocation.clearWatch(geoWatchId);
            geoWatchId = null;
            console.log('üõë Geolocation watch stopped');
        }
    };
});

// Stop tracking button
stopBtn.addEventListener('click', function() {
    console.log('üõë Stopping tracking...');
    
    if (socket) {
        socket.close();
        socket = null;
    }
    
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
        console.log('‚úÖ Geolocation watch stopped');
    }
        // ‚≠ê ADD THIS LINE - Stop the 1-second interval
    if (gpsUpdateInterval) {
        clearInterval(gpsUpdateInterval);
        gpsUpdateInterval = null;
        console.log('‚úÖ GPS update interval stopped');
    }
    
    status.style.backgroundColor = '#f3f4f6';
    status.style.color = '#374151';
    status.innerHTML = '‚èπÔ∏è Tracking stopped.';
    startBtn.disabled = false;
    stopBtn.disabled = true;
    
    lastSentLocation = null;
    lastKnownPosition = null; // ‚≠ê ADD THIS LINE
});

// Prevent accidental page close while tracking
window.addEventListener('beforeunload', function(e) {
    if (socket && socket.readyState === WebSocket.OPEN) {
        e.preventDefault();
        e.returnValue = 'Location tracking is active. Are you sure?';
        return e.returnValue;
    }
});


// Seat toggle functionality
document.querySelectorAll('.seat-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
        const seatId = this.getAttribute('data-seat-id');
        
        fetch('/api/toggle_seat/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}',
            },
            body: JSON.stringify({ seat_id: seatId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                if (data.is_available) {
                    this.classList.remove('seat-occupied');
                    this.classList.add('seat-available');
                } else {
                    this.classList.remove('seat-available');
                    this.classList.add('seat-occupied');
                }
            }
        })
        .catch(error => {
            console.error('Error toggling seat:', error);
        });
    });
});
{% endif %}

// Real-time notifications and chat system
{% if request.user.is_authenticated and request.user.driver_profile %}
(function(){
    const driverId = {{ request.user.id }};
    const chatRoom = 'driver_' + driverId;
    const driverSocket = new WebSocket(
        (location.protocol === 'https:' ? 'wss://' : 'ws://') + 
        window.location.host + '/ws/chat/' + chatRoom + '/'
    );

    driverSocket.onopen = function(){ 
        console.log('‚úÖ Driver chat socket opened:', chatRoom); 
    };
    
    driverSocket.onerror = function(error){
        console.error('‚ùå Driver WebSocket error:', error);
    };

    const notifBox = document.getElementById('driverNotifications');
    const notifBadge = document.getElementById('notifBadge');
    const chatLog = document.getElementById('driverChatLog');
    const chatInput = document.getElementById('driverChatInput');
    const sendBtn = document.getElementById('driverSendChat');

    let groupedNotifications = {};  // Store grouped notifications

    function setBadge(count){
        if (!notifBadge) return;
        if (count && count > 0) {
            notifBadge.innerText = count;
            notifBadge.style.display = 'inline-block';
        } else {
            notifBadge.style.display = 'none';
        }
    }

    // ‚≠ê NEW: Render grouped notifications
    function renderGroupedNotifications() {
        if (Object.keys(groupedNotifications).length === 0) {
            notifBox.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">No notifications yet</div>';
            return;
        }

        // Sort groups by stop order
        const sortedGroups = Object.values(groupedNotifications).sort((a, b) => {
            return (a.order || 9999) - (b.order || 9999);
        });

        let html = '';
        sortedGroups.forEach((group, index) => {
            const rankNum = index + 1;
            const rankEmoji = rankNum === 1 ? '' : rankNum === 2 ? '' : rankNum === 3 ? '' : 'üìç';
            
            html += `
                <div class="notification-group">
                    <div class="notification-group-header">
                        <div style="display: flex; align-items: center;">
                            <span class="notification-rank">${rankNum}</span>
                            <span>${rankEmoji} ${group.stop}</span>
                        </div>
                        <span class="passenger-count-badge">
                            ${group.passengers.length} passenger${group.passengers.length > 1 ? 's' : ''}
                        </span>
                    </div>
                    <div class="notification-group-passengers">
            `;
            
            group.passengers.forEach(passenger => {
                const seenClass = passenger.seen ? '' : 'unseen';
                const timeStr = new Date(passenger.created_at).toLocaleTimeString();
                
                html += `
                    <div class="passenger-item ${seenClass}" 
                         data-user-id="${passenger.user_id}"
                         data-pickup-id="${passenger.id}">
                        <div class="passenger-info">
                            <div class="passenger-name">
                                üë§ ${passenger.username}
                                ${!passenger.seen ? '<span style="color: #f59e0b; margin-left: 8px;">‚óè</span>' : ''}
                            </div>
                            ${passenger.message ? `<div class="passenger-message">üí¨ ${passenger.message}</div>` : ''}
                            <div class="passenger-time">üïí ${timeStr}</div>
                        </div>
                        <button class="clear-passenger-btn" data-pickup-id="${passenger.id}">
                            Clear
                        </button>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
        });

        notifBox.innerHTML = html;
        
        // Add click handlers for passenger items and clear buttons
        addNotificationHandlers();
    }

    // ‚≠ê NEW: Add handlers for passenger items
    function addNotificationHandlers() {
        // Click on passenger to load chat
        document.querySelectorAll('.passenger-item').forEach(item => {
            item.addEventListener('click', function(e) {
                // Don't trigger if clicking the clear button
                if (e.target.classList.contains('clear-passenger-btn')) {
                    return;
                }
                
                const userId = this.getAttribute('data-user-id');
                const pickupId = this.getAttribute('data-pickup-id');
                
                // Mark as selected
                document.querySelectorAll('.passenger-item').forEach(i => {
                    i.style.background = '';
                });
                this.style.background = '#dbeafe';
                
                // Mark as seen
                if (pickupId) {
                    markPickupSeen(pickupId);
                }
                
                // Load chat history
                if (userId) {
                    loadChatHistory(userId);
                }
            });
        });

        // Clear individual pickup
        document.querySelectorAll('.clear-passenger-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                
                const pickupId = this.getAttribute('data-pickup-id');
                if (!pickupId) return;
                
                if (!confirm('Clear this pickup request?')) return;
                
                // Disable button during request
                this.disabled = true;
                this.textContent = 'Clearing...';
                
                fetch('/api/clear_pickup/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: 'pickup_id=' + encodeURIComponent(pickupId)
                })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Reload notifications
                        loadNotifications();
                    } else {
                        alert('Failed to clear pickup request');
                        this.disabled = false;
                        this.textContent = 'Clear';
                    }
                })
                .catch(error => {
                    console.error('Clear pickup error:', error);
                    alert('Network error');
                    this.disabled = false;
                    this.textContent = 'Clear';
                });
            });
        });
    }

    // ‚≠ê NEW: Load notifications with grouping
    function loadNotifications() {
        fetch('/driver/notifications/')
            .then(r => r.json())
            .then(data => {
                if (data && data.status === 'success') {
                    console.log('üìä Loaded notifications:', data);
                    
                    // Update badge
                    setBadge(data.unread_count || 0);
                    
                    // Group notifications by stop
                    groupedNotifications = {};
                    
                    if (data.grouped_stops && Array.isArray(data.grouped_stops)) {
                        data.grouped_stops.forEach(group => {
                            groupedNotifications[group.stop] = group;
                        });
                    } else if (data.pickups && Array.isArray(data.pickups)) {
                        // Fallback: group manually if server didn't provide grouped_stops
                        data.pickups.forEach(pickup => {
                            if (!groupedNotifications[pickup.stop]) {
                                groupedNotifications[pickup.stop] = {
                                    stop: pickup.stop,
                                    order: pickup.stop_order || 9999,
                                    passengers: []
                                };
                            }
                            groupedNotifications[pickup.stop].passengers.push({
                                id: pickup.id,
                                user_id: pickup.user_id,
                                username: pickup.user,
                                message: pickup.message,
                                created_at: pickup.created_at,
                                seen: pickup.seen
                            });
                        });
                    }
                    
                    renderGroupedNotifications();
                }
            })
            .catch(error => {
                console.error('‚ùå Failed to load notifications:', error);
            });
    }

    // Load initial notifications
    loadNotifications();

    // WebSocket message handler
    driverSocket.onmessage = function(e){
        let data;
        try {
            data = JSON.parse(e.data);
        } catch(err){
            console.error('Driver WS parse error', err, e.data);
            return;
        }

        console.log('üì® WebSocket message:', data);

        if (data.type === 'pickup_notification') {
            console.log('üîî New pickup notification received:', data);
            
            // Reload notifications to get updated grouping
            loadNotifications();
            
            // Show browser notification if supported
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('New Pickup Request', {
                    body: `${data.user_username || 'Passenger'} at ${data.stop}`,
                    icon: '/static/bus-icon.png'
                });
            }
        } else if (data.type === 'chat_message') {
            addChatMessage(data);
        }
    };

    function markPickupSeen(pickupId) {
        fetch('/api/mark_pickup_seen/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: 'pickup_id=' + encodeURIComponent(pickupId)
        })
        .then(r => r.json())
        .then(data => {
            if (data && data.status === 'ok') {
                // Reload to update badge count
                loadNotifications();
            }
        })
        .catch(console.error);
    }

    function loadChatHistory(userId) {
        fetch('/messages/' + userId + '/')
            .then(r => r.json())
            .then(data => {
                if (data && data.status === 'success' && Array.isArray(data.messages)) {
                    chatLog.innerHTML = '';
                    data.messages.forEach(function(m){
                        addChatMessage({
                            sender_id: m.sender === '{{ request.user.username }}' ? {{ request.user.id }} : userId,
                            sender_name: m.sender,
                            content: m.content
                        });
                    });
                }
            })
            .catch(console.error);
    }

    function addChatMessage(message) {
        if (chatLog.innerHTML.includes('Select a notification')) {
            chatLog.innerHTML = '';
        }
        
        const el = document.createElement('div');
        el.className = `chat-message ${message.sender_id === {{ request.user.id }} ? 'message-driver' : 'message-user'}`;
        el.innerHTML = `
            <strong>${message.sender_name || 'User'}:</strong> ${message.content}<br>
            <small>${new Date().toLocaleTimeString()}</small>
        `;
        chatLog.appendChild(el);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Clear all notifications
    document.getElementById('clearAllNotifs').addEventListener('click', function(){
        if (!confirm('Clear all pickup notifications? This will allow passengers to request again.')) return;
        
        this.disabled = true;
        this.textContent = 'Clearing...';
        
        fetch('/api/clear_all_pickups/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(r => r.json())
        .then(data => {
            if (data && data.status === 'ok') {
                groupedNotifications = {};
                notifBox.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">No notifications yet</div>';
                setBadge(0);
            }
            this.disabled = false;
            this.textContent = 'Clear All';
        })
        .catch(error => {
            console.error('Clear all error:', error);
            this.disabled = false;
            this.textContent = 'Clear All';
        });
    });

    // Send chat message
    sendBtn.addEventListener('click', function(){
        const content = chatInput.value.trim();
        if (!content) return;
        
        const selectedItem = document.querySelector('.passenger-item[style*="background"]');
        const recipientId = selectedItem ? selectedItem.getAttribute('data-user-id') : null;
        
        if (!recipientId) {
            alert('Please select a passenger from notifications first.');
            return;
        }

        const payload = {
            type: 'chat_message',
            content: content,
            recipient_id: parseInt(recipientId),
            bus_id: {% if bus %}{{ bus.id }}{% else %}null{% endif %}
        };
        
        driverSocket.send(JSON.stringify(payload));
        chatInput.value = '';
    });

    // Clear chat
    document.getElementById('clearDriverChat').addEventListener('click', function(){
        const selectedItem = document.querySelector('.passenger-item[style*="background"]');
        const recipientId = selectedItem ? selectedItem.getAttribute('data-user-id') : null;
        
        if (!recipientId) {
            alert('Please select a conversation first.');
            return;
        }
        
        if (!confirm('Clear all messages with this user?')) return;
        
        fetch('/api/clear_chat/' + recipientId + '/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(r => r.json())
        .then(data => {
            if (data && data.status === 'success') {
                chatLog.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">Select a notification to start chatting</div>';
            }
        })
        .catch(console.error);
    });

    // Enter key to send message
    chatInput.addEventListener('keypress', function(e){
        if (e.key === 'Enter') {
            sendBtn.click();
        }
    });

})();
{% endif %}
{% if route and bus and route.reverse_route %}
// ==================== ROUTE SWITCHING ====================
const switchRouteBtn = document.getElementById('switchRouteBtn');

if (switchRouteBtn) {
    switchRouteBtn.addEventListener('click', function() {
        if (this.disabled) return;
        
        const reverseRouteName = '{{ route.reverse_route.name|escapejs }}';
        const confirmMsg = `Are you sure you want to switch to ${reverseRouteName}?\n\nThis will reset location tracking data.`;
        
        if (!confirm(confirmMsg)) {
            return;
        }
        
        // Show loading state
        this.disabled = true;
        this.innerHTML = '‚è≥ Switching...';
        
        // Make API call
        fetch('/api/switch_route/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                alert('‚úÖ Route switched successfully!\n' + data.old_route + ' ‚Üí ' + data.new_route);
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            } else {
                alert('‚ùå ' + (data.error || 'Failed to switch route'));
                this.disabled = false;
                this.innerHTML = 'üîÑ Switch to {{ route.reverse_route.name|escapejs }}';
            }
        })
        .catch(error => {
            console.error('Route switch error:', error);
            alert('‚ùå Network error. Please check your connection.');
            this.disabled = false;
            this.innerHTML = 'üîÑ Switch to {{ route.reverse_route.name|escapejs }}';
        });
    });
}
{% endif %}
</script>
{% endblock %}
